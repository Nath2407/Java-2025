# ğŸ§  Mejores PrÃ¡cticas en Java: CÃ³digo Limpio, SOLID, Excepciones y OptimizaciÃ³n

## ğŸ¯ Objetivo

âš’ï¸ Aprender a escribir cÃ³digo **limpio**, **robusto** y **mantenible** en Java aplicando principios **SOLID**, detectando y eliminando **code smells**, optimizando el **rendimiento** y utilizando adecuadamente el **manejo de excepciones** (`try-catch`, `throw`, `throws`) y **excepciones personalizadas**.

---

## ğŸ“˜ Material del Prework

Antes de comenzar con los ejercicios de esta sesiÃ³n, recuerda que el **material de prework** cubre los fundamentos teÃ³ricos que aplicaremos. Durante la sesiÃ³n, practicaremos estos conceptos mediante ejemplos y retos para reforzar el aprendizaje.

---

## ğŸ“‚ Temas de la sesiÃ³n

### ğŸ“– RefactorizaciÃ³n y Code Smells

> Refactorizar es mejorar la **estructura** del cÃ³digo sin alterar su **funcionalidad**. Los *code smells* son indicios de que algo necesita mejora.

- CÃ³digo duplicado
- Funciones largas
- Nombres confusos o poco descriptivos
- EliminaciÃ³n de cÃ³digo muerto
- Buenas prÃ¡cticas para simplificar y reutilizar

ğŸ“œ **Ejemplo 01:** RefactorizaciÃ³n y code smells

---

### ğŸ“– Principios SOLID en Java

> Los principios **SOLID** son fundamentales para escribir cÃ³digo orientado a objetos que sea **escalable** y **fÃ¡cil de mantener**.

- **S**RP: Principio de Responsabilidad Ãšnica  
- **O**CP: Principio de Abierto/Cerrado  
- **L**SP: Principio de SustituciÃ³n de Liskov  
- **I**SP: Principio de SegregaciÃ³n de Interfaces  
- **D**IP: Principio de InversiÃ³n de Dependencias

ğŸ“œ **Ejemplo 02:** AplicaciÃ³n de principios SOLID en Java  
ğŸ”¥ **Reto 01:** Motor de lÃ³gica narrativa

---

### ğŸ“– TÃ©cnicas para Mejorar el Rendimiento

> Escribir cÃ³digo eficiente mejora la **experiencia del usuario** y reduce el **consumo de recursos**.

- Uso adecuado de estructuras de datos (`ArrayList`, `HashMap`, `HashSet`)
- ReducciÃ³n de la complejidad en mÃ©todos
- GestiÃ³n de memoria y recursos

ğŸ“œ **Ejemplo 03:** TÃ©cnicas para mejorar el rendimiento

---

### ğŸ“– Manejo de Excepciones con try-catch-finally

> Las excepciones permiten manejar errores de forma **segura** y **controlada**.

- Tipos de excepciones: *checked* y *unchecked*
- Estructura `try-catch-finally`
- Evitar caÃ­das inesperadas del programa

ğŸ“œ **Ejemplo 04:** Manejo de excepciones con try-catch-finally

---

### ğŸ“– Uso de throw, throws y Excepciones Personalizadas

> Cuando las excepciones predefinidas no son suficientes, puedes crear **excepciones personalizadas**.

- `throw`: lanzar una excepciÃ³n
- `throws`: declarar que un mÃ©todo puede lanzar una excepciÃ³n
- DiseÃ±o e implementaciÃ³n de excepciones personalizadas

ğŸ“œ **Ejemplo 05:** Uso de throw, throws y excepciones personalizadas  
ğŸ”¥ **Reto 02:** Monitoreo de consumo de recursos en servidores

---

## âœ… ConclusiÃ³n

Esta sesiÃ³n te brinda herramientas clave para mejorar la **calidad del cÃ³digo**, facilitar su **mantenimiento** y asegurar su **robustez**, especialmente en contextos de producciÃ³n y entornos de desarrollo profesional.

---

FUENTE:BEDU
